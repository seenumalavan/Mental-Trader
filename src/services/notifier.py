import logging
import httpx
import asyncio
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import smtplib
from src.config import settings

logger = logging.getLogger("notifier")

class Notifier:
    def __init__(self, webhook_url: str = "", smtp_server: str = "smtp.gmail.com", smtp_port: int = 587):
        """Initialize Notifier with webhook URL and async HTTP client."""
        self.webhook = webhook_url
        self.client = httpx.AsyncClient(timeout=5.0)
        # Validate SMTP configuration
        self.smtp_enabled = (
            settings.SMTP_ENABLE
            and settings.SMTP_USERNAME
            and settings.SMTP_PASSWORD
            and settings.SMTP_TO
            and settings.SMTP_FROM
        )

        self.smtp_server = smtp_server
        self.smtp_port = smtp_port

    async def _send_email(self, subject: str, html_body: str, plain_text: str):
        """Send an email with both HTML and plain text content."""
        if not self.smtp_enabled:
            logger.debug("SMTP is disabled or not configured properly")
            return

        # Create multipart email
        msg = MIMEMultipart("alternative")
        msg["Subject"] = subject
        msg["From"] = settings.SMTP_FROM
        msg["To"] = settings.SMTP_TO

        # Attach plain text and HTML parts
        part1 = MIMEText(plain_text, "plain")
        part2 = MIMEText(html_body, "html")
        msg.attach(part1)
        msg.attach(part2)

        loop = asyncio.get_running_loop()
        try:
            def _send():
                with smtplib.SMTP(self.smtp_server, self.smtp_port, timeout=10) as server:
                    server.starttls()
                    server.login(settings.SMTP_USERNAME, settings.SMTP_PASSWORD)
                    server.send_message(msg)
            await loop.run_in_executor(None, _send)
            logger.info("Email sent successfully: %s", subject)
        except Exception:
            logger.exception("Failed to send email: %s", subject)

    async def notify_signal(self, signal):
        """Send a trade/option signal in both JSON (webhook) and email (HTML + plain text).

        Args:
            signal: Object containing signal data (trade or option).
        """
        # Determine signal type and build message fields
        is_option = hasattr(signal, "contract_symbol")
        if is_option:
            msg = {
                "contract_symbol": signal.contract_symbol,
                "underlying_side": signal.underlying_side,
                "strike": signal.strike,
                "kind": signal.kind,
                "premium_ltp": signal.premium_ltp,
                "lots": signal.suggested_size_lots,
                "stop_loss_premium": signal.stop_loss_premium,
                "target_premium": signal.target_premium,
            }
            title = f"Option Signal: {signal.underlying_side} {signal.contract_symbol}"
        else:
            msg = {
                "symbol": signal.symbol,
                "side": signal.side,
                "price": signal.price,
                "size": signal.size,
                "stop_loss": signal.stop_loss,
                "target": signal.target,
            }
            title = f"Trade Signal: {signal.side} {signal.symbol}"

        # Construct HTML payload
        rows = [
            f"<tr><td style='padding:4px 8px;font-weight:600;text-transform:capitalize'>{k.replace('_', ' ')}</td><td style='padding:4px 8px;text-align:right'>{v}</td></tr>"
            for k, v in msg.items()
        ]
        html = (
            "<div style='font-family:Arial, sans-serif;font-size:14px'>"
            f"<h3 style='margin:0 0 8px;color:#0b5394'>{title}</h3>"
            "<table style='border-collapse:collapse;min-width:300px'>"
            + "".join(rows)
            + "</table>"
            "<p style='font-size:11px;color:#666;margin-top:10px'>Generated by Mental-Trader</p>"
            "</div>"
        )

        # Create plain text version for logging and email fallback
        plain_text = f"{title}\n" + "\n".join(f"{k}: {v}" for k, v in msg.items())

        # Prepare webhook payload
        payload = {**msg, "html": html, "title": title, "type": "option" if is_option else "trade", "text": plain_text}

        # Log signal if no webhook is configured
        if not self.webhook:
            logger.info("Signal (no webhook): %s", plain_text.replace("\n", " | "))
            if self.smtp_enabled:
                await self._send_email(subject=title, html_body=html, plain_text=plain_text)
            return

        # Send webhook and email
        try:
            await self.client.post(self.webhook, json=payload)
            logger.info("Webhook sent successfully: %s", title)
            if self.smtp_enabled:
                await self._send_email(subject=title, html_body=html, plain_text=plain_text)
        except Exception:
            logger.exception("Failed to send signal via webhook")

    async def __aenter__(self):
        """Support async context manager for HTTP client."""
        return self

    async def __aexit__(self, exc_type, exc, tb):
        """Close HTTP client on context manager exit."""
        await self.client.aclose()